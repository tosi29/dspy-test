import dspy
from dspy.teleprompt import MIPROv2
import os
import glob
import json

# --- 1. Dataset Loading ---
def load_dataset():
    """datasetフォルダからノートとブログのペアを読み込む"""
    notes_path = "dataset/notes/*.txt"
    dataset = []
    
    for note_file in glob.glob(notes_path):
        # ファイル名からベース名を取得 (例: "remote_work")
        base_name = os.path.basename(note_file)
        blog_file = os.path.join("dataset/blogs", base_name)
        
        if os.path.exists(blog_file):
            with open(note_file, 'r', encoding='utf-8') as f:
                notes_text = f.read().strip()
            with open(blog_file, 'r', encoding='utf-8') as f:
                blog_text = f.read().strip()
            
            # Exampleを作成。notesを入力、blogを正解データとする
            example = dspy.Example(notes=notes_text, blog=blog_text).with_inputs("notes")
            dataset.append(example)
    
    return dataset

# データを読み込み
full_dataset = load_dataset()
if not full_dataset:
    print("Error: データが見つかりません。dataset/notes と dataset/blogs にファイルがあるか確認してください。")
    exit()

# 訓練用データとして全て使用（デモのため）
trainset = full_dataset

# --- 2. Module Definition (The Student) ---
class BlogWriter(dspy.Module):
    def __init__(self):
        super().__init__()
        # 思考の連鎖(CoT)を使ってブログを書く
        # 入力: notes (箇条書きメモ)
        # 出力: blog (ブログ記事)
        self.prog = dspy.ChainOfThought("notes -> blog")
    
    def forward(self, notes):
        return self.prog(notes=notes)

# --- 3. Metric Definition (LLM-as-a-Judge) ---
# 評価を行うための署名（Signature）
class BlogJudgeSignature(dspy.Signature):
    """
    You are an expert editor. 
    Evaluate the generated blog post based on the provided notes.
    Criteria:
    1. Coverage: Does the blog cover all key points from the notes?
    2. Quality: Is the writing engaging, professional, and well-structured?
    3. Format: Is it formatted as a blog post (e.g., with headings)?
    
    Give a score from 1 to 5, where 5 is perfect.
    """
    notes = dspy.InputField(desc="The source notes provided to the writer")
    generated_blog = dspy.InputField(desc="The blog post generated by the writer")
    reasoning = dspy.OutputField(desc="Explanation for the score")
    score = dspy.OutputField(desc="A integer score between 1 and 5", dtype=int)

# 評価関数
def validate_blog(example, pred, trace=None):
    # 評価用の小さなモジュールを用意
    judge = dspy.ChainOfThought(BlogJudgeSignature)
    
    # 正解データ(example.blog)は参照用としてあるが、
    # ここでは「メモ(notes)から良いブログ(pred.blog)が書けているか」を判定する
    # ※厳密な比較ではなく、質的な評価を行う
    try:
        result = judge(notes=example.notes, generated_blog=pred.blog)
        score = int(result.score)
        
        # 4点以上なら合格（True）とする
        return score >= 4
    except Exception as e:
        print(f"Metric Error: {e}")
        return False

def main():
    # APIキーの確認
    if not os.environ.get("GOOGLE_API_KEY"):
        print("エラー: GOOGLE_API_KEY環境変数が設定されていません。")
        return

    # Language Modelの設定
    lm = dspy.LM('gemini/gemma-3-27b-it')
    dspy.configure(lm=lm)

    print(f"\n--- Loaded {len(trainset)} examples from dataset/ folder ---")

    print("\n--- Initializing MIPROv2 (Zero-Shot Prompt Optimization) ---")
    
    # MIPROv2の初期化
    # MetricにLLM審査員を使用
    teleprompter = MIPROv2(metric=validate_blog, num_candidates=3, auto=None)
    
    print("Compiling with MIPROv2...")
    print("Objective: Find the best Zero-shot instruction to turn notes into a blog.")
    
    # コンパイル（学習）
    # Zero-shot最適化のため、デモ数は0に設定
    compiled_blog_writer = teleprompter.compile(
        student=BlogWriter(),
        trainset=trainset,
        max_bootstrapped_demos=0, # 事例生成なし
        max_labeled_demos=0,      # 教師データ事例の使用なし
        minibatch=False,
        num_trials=4, # デモ用に試行回数を減らす
    )

    # --- Optimized Execution ---
    print("\n--- Optimized Execution Check ---")
    
    # テスト用の新しいメモ
    test_notes = """
    - 良い睡眠をとるためには、寝る前のスマホを控える
    - お風呂は就寝の90分前に済ませるのが理想
    - 室温は20度〜25度くらいが快適
    - 朝起きたら日光を浴びて体内時計をリセットする
    """
    
    print(f"Input Notes:\n{test_notes}")
    pred = compiled_blog_writer(test_notes)
    
    print("\n" + "="*20 + " Generated Blog " + "="*20)
    print(pred.blog)
    print("="*56)
    
    # Capture optimized prompt
    optimized_prompt = "No history"
    if lm.history:
        # 履歴から最後のプロンプト（最適化された指示が含まれている）を取得
        last_entry = lm.history[-1]
        if "messages" in last_entry:
            optimized_prompt = last_entry["messages"]
        elif "prompt" in last_entry:
            optimized_prompt = last_entry["prompt"]
        else:
            optimized_prompt = str(last_entry)

    print("\n" + "="*20 + " Optimized Prompt (Instruction) " + "="*20)
    print(json.dumps(optimized_prompt, indent=2, ensure_ascii=False))
    print("="*70)

    # 保存
    # compiled_blog_writer.save("blog_writer_optimized.json")

if __name__ == "__main__":
    main()
